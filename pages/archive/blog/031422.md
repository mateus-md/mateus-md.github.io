## How I think a modern OS should be
Now a days we have only three major OS: Windows, MacOS and Linux (sorry SolarisOS and friends). Two UNIX-like and a DOS-like one. I won't even start talking about Windows - it's a talk for another day - Linux and MacOS are the main subject today.

MacOS is fair enough. We don't have access to its code base. We only know that its Kernel is based on a BSD Kernel (yet another UNIX-like system), beyond that we can't talk further more. People told me it's good enough for developers and common users in general, despite some _Apple issues_ (thanks for your bad legacy, Mr. Jobs). But Linux **IS** open source. We do can look at its entire source code (I don't recommend doing so) if we wish so.

In the realm of the ideas, where Utopian Socialism and Lockie's Liberalism lives, Linux and the ecosystem created by it and its community is perfect. Beyond perfect. But when we fall from the skies and return to the real world, it's not that good.

Don't get me wrong, I would rather use Linux over Windows without even thinking about that, but yet it could be better. Linux is fulfilled (better undertood when in Portuguese, _"entupido"_) with legacy code and outdated costumes. For example, do we still need to use that giant libc code with hundreds of thousands of messy spaghetti code? Macros using macros to change in compiletime typedefs to support deprecated software, dozens of weird and non-intuitive types and _gambiarras_ like boolean arrays defined at size 0 within structures to store another array by reference turning it into a pseudo void pointer? Do we need to keep support to peripherals that aren't even produced? Like, what the hell, dude? Are you drunk? Do we need that level of nesting and complexity? Come on, man. Help me help you. If you don't believe me, just open any file of your libc source or the Linux Kernel itself and try to understand by the first try. Programming should not be complex to read or understand. There are so many calls for functions that are only used once or only in a single scope that it seems the programmer wanted to softly-encrypt his program's source code. The Linux Kernel and most GNU software have a lot of this. It's barely impossible to get an overview of Linux kernel codebase without help of someone already on it. If you don't agree, see the really good video of Brian Will on [replacing the Unix Tradition](https://www.youtube.com/watch?v=L9v4Mg8wi4U). There are even a concept called the [Dependency Hell](https://en.wikipedia.org/wiki/Dependency_hell) that is directly caused by this kind of messy code. Now, if you take a look on [Redox OS source code](https://gitlab.redox-os.org/redox-os/kernel/-/tree/master/src) you'll see a clear, simple and easy to fallow up code (you may not underestand how it work, but you know more or less what it does).

"But it's rust. Rust is more clear than C" some may say, so take a look on [SnowflakeOS](https://github.com/29jm/SnowflakeOS) and I'll see that is possible to write clear yet complex C code (btw I didn't see the entire code base, but as far as I saw it was good enough).

"So, how it should be?", another may ask. Well, a good program is not the larger or the most complex, is the most efficient. And by using this term I don't mean the fastest, I mean the more consistent, well implemented and simple code. Because you may have the fastest Kernel in the world, but if you can't fix any bug because it's too confusing then it's not efficient. A good Operational System may be easy to maintain, adapt, enhance and improve. No one will really care if you take 2 more seconds to boot if the OS is unbelievable stable. So this is the first point. Linux is not easy to maintain, probably Windows neither, and so on the others.

Secondly, a good approach for kernels are [microkernels](https://en.wikipedia.org/wiki/Microkernel). Microkernels make the system simpler by simply moving the responsability of keep the programs working well to the programs themselves. If the only job of the OS is manage memory, keep comunication between programs and keep programs alway from other's data, the system gets smaller, more efficient and, again, simpler. Simplicity is good because help us keep things organized. As Jonathan Blow once said in one of his [livestreams](https://www.youtube.com/watch?v=k0uE_chSnV8), talk to hardware and do low-level stuff should be a responsability of the programs and/or their libraries, not of the system. And so we are brought to the next item: libraries.

Third: the applications and their libraries. On my idealized OS, there are only two types of users and two types of programs: the admin and the guest users and the system and user programs. Admin you can call by _sudo user_ or anything like that. They can manage the system; install and update system programs and libraries, create and delete user's profiles/userspaces and so on. Guest users can only install local applications, the user programs. Speaking of which, the user programs are those like games and browsers; they do not need to access the system log or change other's data, they just do local things. Now, the system programs are those, like package managers and file explorers, that can change everyone's data and change the system itself, so only someone with admin privileges can _completely_ use them (guest users may use the file explorer, for example, but they can only manage their _own_ files). No user groups, no file ownership shit, no file hierarchy. "But if a program uses another program's library or something like that?". Well, simply sandbox the programs. If they need a library, download the corresponding version and assign it to them. It's actually really simple just create a folder called "babiriboboo" and put "babiri-v3.1/3.2/3.x" inside of it. If you deleted the program that needed a library and don't wanna keep it anymore, just delete it as you wish. Also, good programs should not has non-essential dependencies like xfce does (if you install it on linux you also have to install Thunar, for example). If you want a program, you should be able to download _only_ that program. And you should be guaranteed that installing or removing it won't fuck with the entire system. So many times I had (and still have to) keep Python 2.1, 2.3, 3.1, 3.4 or be whatever version this shit is packed up to run legacy programs that are needed by the actual programs I want to use. This Dependency Hell should be avoided by simply sandboxing programs and keeping no default version of the libaries (also, fuck Python, this shit changes drastically every six months and I'm obligated to keep dozens of versions to keep the programs I need keep working. I hate python and I'll soon talk more about why).

I'm really planning to start a hobby OS (actually I already started one called pxdevOS some time ago) when I'm done with [B++](/archive/blog/092421). I have some other ideas for it as the system only running a single "startup" program on boot that can be changed by the admin easily (making possible to convert the entire system from GUI-oriented to Terminal-oriented, or make it an emulator system and so on), and getting rid of shellscript once and for all, etc. Some day I'll do it, I promise. But first let me finish the already going projects and learn more about Operating Systems. Until there, try your best to be happy with your system, and, if possible, also try to help their maintainers keep improving it. _See ya!_