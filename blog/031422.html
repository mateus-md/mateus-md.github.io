<html>
    <head>
        <title>mmd's blog</title>
        <link rel="stylesheet" href="../config.css"/>
        <link rel="icon" href="icon.png">

        <link rel="preconnect" href="https://fonts.googleapis.com">
        <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
        
        <link href="https://fonts.googleapis.com/css2?family=Patrick+Hand+SC&display=swap" rel="stylesheet">
        <link href="https://fonts.googleapis.com/css2?family=DM+Mono&display=swap"         rel="stylesheet">
        <link href="https://fonts.googleapis.com/css2?family=PT+Mono&display=swap"         rel="stylesheet">
        <link href="https://fonts.googleapis.com/css2?family=Share+Tech+Mon&display=swap"  rel="stylesheet">

        <script src="../auto_header.js"></script>
    </head>
    <body onload = "init_header('../')">
        <header>
            <!-- Head -->
            <h1 align = "center" class = "title"><u><a href="index.html" title="making stuff since 4 B.W." target="_blank">mmd's blog</a></u></h1>
            <hr align = "center"/>

            <!-- Menu -->
            <nav id = "header"></nav>
            <hr align = "center"/>
        </header>

        <!-- Body -->
        <main class = "default" id = "data" align = "justify">
            <h3>How I think a modern OS should be</h3><p>Now a days we have only three major OS: Windows, MacOS and Linux (sory SolarisOS and friends). Two UNIX-like and a DOS-like OS. I won't even start talking about Windows, it's a talk for another day; but Linux and MacOS are the main talk today.</p><p>MacOS is fair enough. We don't have access to its code base, we only know that its Kernel is based on BSD Kernel (yet another UNIX-like system), beyond that we can't talk further more. People told me it's pretty good for developers and common users in general, despite some <i>Apple issues</i> (thanks for your bad legacy, Mr. Jobs). But Linux IS open source. We can look at its entire source code (I don't recommend doing so). In the realm of the ideas, where Utopian Socialism and Lockie's Liberalism lives, Linux and the ecosystem created by it and its community is perfect. Beyond perfect. But when we fall from the skies and return to the real world, it's not that good.</p>Don't get me wrong, I prefer Linux over Windows tons of times, but yet it could be better. Linux is fulfilled (better undertood when in Portuguese, <i>"entupido"</i>) with legacy code and outdated costumes. For example, do we still need to use that giant libc code with hundreds of thousands of messy spaghetti code? Macros using macros to change in compiletime typedefs to support deprecated software, dozens of weird and non-intuitive types and <i>gambiarras</i> like boolean arrays defined at size 0 within structures to store another array by reference turning it into a pseudo void pointer? Like, what the hell, dude? Are you drunk? Do we need that level of nesting and complexity? Come on, man. Help me help you. If you don't believe me, just open any file of your libc source or the Linux Kernel itself and try to understand by the first try. Programming should not be complex to read or understand. There are so many calls for functions that are only used once or only in a single scope that it seems the programmer wanted to soft-encrypt his program's source code. The Linux Kernel and most GNU software wave a lot of it. It's barely impossible to get an overview of Linux source without help of someone already on it. If you don't agree, see the really good video of Brian Will on <a href="https://www.youtube.com/watch?v=L9v4Mg8wi4U" target="_blank">replacing the Unix Tradition</a> (also, his video on <a href="https://www.youtube.com/watch?v=IRTfhkiAqPw" target="_blank" >OOP Programming is embarrassing</a> prompts some modern and common issues on people's code too). There even a concept called the <a href="https://en.wikipedia.org/wiki/Dependency_hell" target="_blank" >Dependency Hell</a> that is directly caused because of this kind of messy code. Now, if you take a look on <a href="https://gitlab.redox-os.org/redox-os/kernel/-/tree/master/src" target="_blank" >Redox OS source code</a> you'll see a clear, simple and easy to fallow up code (you may not underestand how it work, but you know more or less what it does). "But it's rust. Rust is more clear than C" some may say, so take a look on <a href="https://github.com/29jm/SnowflakeOS" target="_blank" >SnowflakeOS</a> and I'll see that is possible to write clear yet complex C code (btw I didn't see the entire code base, but as far as I saw it was good enough).<p>"So, how it should be?", another may ask. Well, a good program is not the larger or the most complex, is the most efficient. And by using this term I don't mean the fastest, I mean the more consistent, well used and simple code. Because you may have the fastest Kernel in the world, but if you can't fix any bug because it's too confusing then it's not efficient. A good Operational System may be easy to maintain, adapt, enhance and improve. No one will really care if you take 2 more seconds to boot if the OS is unbelievable stable. So this is the first point. Linux is not easy to maintain, probably Windows neither, and so on the others.</p>Secondly, a good approach for kernels are microkernels. Microkernels make the system simpler by simply moving the responsability of keep the programs working well to the programs themselves. If the only job of the OS is manage memory, keep comunication between programs and keep programs alway from other's data, the system gets smaller, more efficient and, again, simpler. Simplicity is good because help us keep things organized. As Jonathan Blow once said on one of his <a href="https://www.youtube.com/watch?v=k0uE_chSnV8" target="_blank" >livestreams</a>, talk to hardware and do low-level stuff should be a responsability of the programs and their libraries, not of the system. And so we are brought to the next item: libraries.<p>Third: the applications and their libraries. On my idealized OS, there are only two types of users and two types of programs: the admin and the guest users and the system and user programs. Admin you can call by <i>sudo user</i> or anything like that. He can manage the system; install and update system programs and libraries, create and delete user's profiles/userspaces and so on. Guest users can only install local applications, the user programs. Speaking of which, the user programs are those like games and browsers; they do not need to access the system log or change other's data, they just do local things. Now, the system programs are those like package managers and file explorers, they can change everyone's data and change the system itself, so only someone with admin privileges can [completely] use them (guest users may use the file explorer, but they can only manage their <i>own</i> files). No user groups, no ownership hell, no file hierarchy. "But if a program uses another program's library or something like that?". Well, simply sandbox the programs. If they need a library, download the corresponding version and assign it to them. Is actually really simple just create an folder called "babiriboboo" and put "babiri-v3.1/3.2/3.x" inside of it. If you delete the program that needed that library, just delete it as you wish. Also, good programs should not has non-essential dependencies like Xfce does (if you install it on linux you also have to install Thunar, for example). If you want a program, you should be able to download <i>only</i> that program. And you should be guaranteed that installing or removing it won't fuck with the entire system. So many times I had (and still have to) keep Python 2.1, 2.3, 3.1 and 3.4 to run legacy programs that are needed by the actual programs I want to use. This Dependency Hell should be avoided by simply sandboxing programs and keeping no default version of the libaries (also, fuck Python, this shit changes drastically every six months and I'm obligated to keep dozens* of versions to keep the programs I need working. Why would you say "hey dudes, this lang you are using (python 2) is no longer supported, please use this almost completely incompatible new version instead"? I hate python and I'll soon talk more about why).</p>I'm really planning to start a hobby OS (actually I already started one called pxdevOS some time ago) when I'm done with <a href="https://mateus-md.github.io/blog/B%20is%20for%20Better.html" target="_blank" >B++</a>. I have some other ideas for it as the system only running a single "startup" program on boot that can be changed by the admin easily (making possible to convert the entire system from GUI-oriented to Terminal-oriented, or make it an emulator system and so on), and getting rid of shellscript once and for all, etc. Some day I'll do it, I promise. But first let me finish the already going projects and learn more about Operating Systems. Until there, try your best to be happy with your system, and, if possible, also try to help their maintainers keep improving it. <i>See ya!</i>
        </main>

        <!-- Footnote -->
        <hr align = "center"/>
        <footer class="footnote" id = "footnote">
        </footer>
    </body>
</html>